# lib/reproduce.evo
# Exportierte Reproduktion des Organimus
.INCLUDE "lib/state.evo"
.REQUIRE "lib/state.evo" AS STATE

.REG %CONTCORD %LR0 # Koordinate um die Reproduktion fortzusetzen
#.REG %FORKCORD %LR1 # Koorinate in der rechten oberen Ecke, von der aus der FORK Prozess gestartet werden kann

# ----------------------------
# Constants
# ----------------------------
.DEFINE REPRODUCTION_PAUSE_THRESHOLD DATA:50000
.DEFINE REPRODUCTION_CHILD_INITAL_ENERGY DATA:25000

# DATA-Felder in der Zeile über CONTINUE_INIT (x=0..2, y=-1 relativ zu CONTINUE_INIT)
.ORG 0|1
CONTINUE_STATE: EXPORT
.PLACE DATA:0   1|1       # %DIRMASK
.PLACE DATA:-1  2|1       # %DIRVEC

.ORG 0|0
.PROC CONTINUE EXPORT REF ER

  .PREG %SHELL   %PR0     # Hüllen Molekül als Terminator Symbol
  .PREG %DIRMASK %PR1     # Richtung der Reproduktion als Bitmaske - static local state
  .PREG %DIRVEC  %PR2     # Richtung der Reproduktion als Vektor
  .PREG %SIDEVEC %PR3     # In der ersten und letzten Zeile Vektor zu Hüllenseite, sonst DATA:0, im local state DATA:1 für rechts (letzte Zeile) und DATA:-1 für links (erste Zeile)
  .PREG %TMP     %PR4     # Tempräres register für schenlle Vergleiche

  NOP^4; JMPI CONTINUE_INIT; NOP^48; JMPI CONTINUE_INIT

  .ORG 0|2
  CONTINUE_INIT:                              # State laden
    STATIC2_LOAD CONTINUE_STATE %DIRMASK %SIDEVEC; NOP
    SMRI DATA:1; NOP^2                             # Marker auf 1 setzen für Ownership-Transfer bei FORK
    SMRI DATA:1; NOP^2                             # Redunandanz
    JMPI CONTINUE_INIT2; NOP^11; JMPI CONTINUE_INIT2

  .ORG 0|3
  CONTINUE_INIT2:                                 # Wir brauchen ein Shell Molekül als Terminator Symbol
    DPLS                                          # alten DP sichern
    SYNC; NOP^4
    SEKI -1|0;
    SEKI -1|0;
    SCNI %SHELL -1|0; NOP^4                       # Hüllen Molekül als Terminator Symbol merken
    GTI %DIRMASK DATA:0                           # Wenn es schon eine Richtung gibt,...
      JMPI CONTINUE_DIRVEC; NOP^4                 # ... dann nicht neu zufällig auswählen

    # Richtung der Reproduktion zufällig auswählen
    SETI %DIRMASK DATA:15; NOP^4                  # Alle 4 Richtungen
    RBIR %DIRMASK %DIRMASK; NOP^4                 # Zufälliges gesetztes Bit aus %DR0 -> %DR1
    JMPI CONTINUE_DIRVEC; NOP^9; JMPI CONTINUE_DIRVEC

  .ORG 0|4
  CONTINUE_DIRVEC: NOP^4
    B2VR %DIRVEC %DIRMASK; NOP^4                    # Bitmaske -> Einheitsvektor

    # %SIDEVEC aus State und %DIRVEC berechnen
    IFI %SIDEVEC DATA:0
      JMPI CONTINUE_SIDEVEC_0; NOP^4
    LTI %SIDEVEC DATA:0
      JMPI CONTINUE_SIDEVEC_L; NOP^4
    SETR %SIDEVEC %DIRVEC; NOP^4
    RTRI %SIDEVEC DATA:1 DATA:0; NOP^4
    JMPI CONTINUE_SIDEVEC_DONE; NOP^8; JMPI CONTINUE_SIDEVEC_DONE

  .ORG 0|5
  CONTINUE_SIDEVEC_L: 
    SETR %SIDEVEC %DIRVEC; NOP^4
    RTRI %SIDEVEC DATA:0 DATA:1; NOP^4
    JMPI CONTINUE_SIDEVEC_DONE; NOP^4; JMPI CONTINUE_SIDEVEC_DONE

  CONTINUE_SIDEVEC_0: 
    SETV %SIDEVEC 0|0; NOP^4
    JMPI CONTINUE_SIDEVEC_DONE; NOP^4; JMPI CONTINUE_SIDEVEC_DONE

  CONTINUE_SIDEVEC_DONE:
    # Wenn wir eine Koordinate zum fortsetzen haben, dann nach CONTINUE_LOOP, sonst zu Kante laufen
    LRDS %CONTCORD; NOP^4
    PUSV 0|0; NOP^4
    INS
      JMPI CONTINUE_LOOP; NOP^4
    JMPI CONTINUE_BORDERMOVE; NOP^4; JMPI CONTINUE_BORDERMOVE

  .ORG 0|6
  ## Beide DPs an die Ausgangsposition setzen
  # in %DIRVEC laufen, bis ich auf die hülle treffe
  CONTINUE_BORDERMOVE: NOP^4
    INPR %DIRVEC                     # Wenn das Molekül nicht passierbar ist,...
      PEEK %TMP %DIRVEC; NOP^4       # ... dann lösche ich es
    SCAN %TMP %DIRVEC; NOP^4         # Was liegt da vor mir?
    IFR %TMP %SHELL                  # Ist es meine Hülle?...
      JMPI CONTINUE_TURNLEFTCORNER; NOP^4 # ... Dann laufe zur Ecke
    SEEK %DIRVEC; NOP^4              # Laufe vorwärts
    JMPI CONTINUE_BORDERMOVE; NOP^4; JMPI CONTINUE_BORDERMOVE

  CONTINUE_TURNLEFTCORNER: NOP^4
    RTRI %DIRVEC DATA:0 DATA:1; NOP^4 # Nach links drehen
    JMPI CONTINUE_CORNERMOVE; NOP^3; JMPI CONTINUE_CORNERMOVE

  .ORG 0|7
  # bis in die linke ecke laufen
  CONTINUE_CORNERMOVE:
    INPR %DIRVEC                   # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %DIRVEC; NOP^4     # ... dann lösche ich es
    SCAN %TMP %DIRVEC; NOP^4         # Was liegt da vor mir?
    IFR %TMP %SHELL                # Ist es meine Hülle?...
      JMPI CONTINUE_CORNERFINISH; NOP^4 # ... Dann sind wir in der Ecke angekommen und erstmal fertig
    SEEK %DIRVEC; NOP^4              # Laufe vorwärts
    JMPI CONTINUE_CORNERMOVE; NOP^4; JMPI CONTINUE_CORNERMOVE

  # In Reporduktionsrichtung drehen und Position merken
  CONTINUE_CORNERFINISH:
    RTRI %DIRVEC DATA:1 DATA:0; NOP^4 # Nach rechts drehen
    DPLR %CONTCORD; NOP^2           # Continue-Position erreicht -> speichern
    #DPLR %FORKCORD                 # FORK-Position merken
    JMPI CONTINUE_LOOP; NOP^3; JMPI CONTINUE_LOOP

  .ORG 0|8
  CONTINUE_LOOP:
    NRG ER; NOP^4                              # ER in %NRG lesen (Cost 1)
    LTI ER REPRODUCTION_PAUSE_THRESHOLD;       # wenn ER < Threshold ...
      JMPI CONTINUE_SAVE_AND_RET; NOP^4        # ... dann State speichern & zurück

    # Defensive Prüfung: Ist %CONTCORD gültig (nicht 0|0)?
    LRDS %CONTCORD
    PUSV 0|0
    IFS                                        # If Same (= 0|0)
      JMPI CONTINUE_BORDERMOVE          # → Neu starten

    # DP0 und DP1 sichern und an Continue-Position holen
    ADPI DATA:0; NOP^4
    DPLS; NOP^4
    SKLR %CONTCORD; NOP^4
    ADPI DATA:1; NOP^4
    DPLS; NOP^4
    SKLR %CONTCORD; NOP^3
    JMPI CONTINUE_WRITEINIT; NOP^4; JMPI CONTINUE_WRITEINIT

  .ORG 0|9
  CONTINUE_WRITEINIT:
    # Schreibvorgang vorbereiten - Defensive Prüfung ZUERST
    IFFR %DIRVEC                   # Ist die erste Zelle FREMD?
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^4 # ... dann abbrechen
    INPR %DIRVEC                   # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %DIRVEC            # ... dann lösche ich es (jetzt sicher!)
    SEEK %DIRVEC; NOP              # Vorwärts
    IFFR %DIRVEC                   # Ist die NÄCHSTE Zelle FREMD?
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^4 # ... dann abbrechen
    INPR %DIRVEC                   # Wenn nicht passierbar (aber nicht fremd),...
      PEEK %TMP %DIRVEC; NOP       # ... dann löschen (unowned oder eigen)
    POKE %SHELL %DIRVEC            # Hülle schreiben
    SEEK %DIRVEC                    # Vorwärts
    #INPR %DIRVEC                   # Wenn das Molekül nicht passierbar,...
    #  PEEK %TMP %DIRVEC            # ... dann lösche ich es


    # Lese DP auf die Hülle setzen
    ADPI DATA:0; NOP^4
    SEEK %DIRVEC

    # Nach innen drehen zum Lesen
    RTRI %DIRVEC DATA:0 DATA:1; NOP^4
    RTRI %DIRVEC DATA:0 DATA:1

    # Stop-Molekül auf den DS legen, damit Schreib-DP weiß wo er aufhören muss, und Lesevorgang aktivieren
    PUSH %SHELL
    JMPI CONTINUE_READLINE; NOP^4; JMPI CONTINUE_READLINE

  .ORG 0|10
  # Loop: Nicht passierbares PEEKen, auf Hülle testen, Molekül vor uns auf den DS legen, vorwärts
  CONTINUE_READLINE:
    SCAN %TMP %DIRVEC; NOP^4       # Was liegt da vor mir?
    IFR %TMP %SHELL                # Ist es meine Hülle?...
      JMPI CONTINUE_WRITESTART; NOP^4 # ... Dann mit dem Schreiben anfangen
    INPR %DIRVEC                   # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %DIRVEC; NOP^4     # ... dann lösche ich es
    PUSH %TMP; NOP^4               # Molekül auf den DS legen
    SEEK %DIRVEC; NOP^2            # Laufe vorwärts
    JMPI CONTINUE_READLINE; NOP^4; JMPI CONTINUE_READLINE

  CONTINUE_WRITESTART:
    ADPI DATA:1; NOP^4               # Schreinvorgang einleiten
    RTRI %DIRVEC DATA:0 DATA:1     # Richtung nach außen drehen zum schreiben
    RTRI %DIRVEC DATA:0 DATA:1; NOP^3
    JMPI CONTINUE_WRITELINE; NOP^4; JMPI CONTINUE_WRITELINE

  .ORG 0|11
  CONTINUE_WRITELINE: NOP^4     # Schreib Loop
    POP %TMP; NOP^4             # Nächstes Symbol von DS holen
    IFR %TMP %SHELL                # Kommt als nächstes das Terminator Symbol?
      JMPI CONTINUE_WRITEFINISH; NOP # Dann Zeilenabschluss

    # Defensive Prüfung vor PPKR: Nur bei FREMD abbrechen
    IFFR %DIRVEC                   # Ist die Zelle FREMD?
      JMPI CONTINUE_CLEANUP_STACK; NOP^4 # ... dann abbrechen (Stack enthält noch SHELL + Moleküle)
    JMPI CONTINUE_WRITELINE2; NOP^28; JMPI CONTINUE_WRITELINE2

  .ORG 0|12
  CONTINUE_WRITELINE2:
    PPKR %TMP %DIRVEC; NOP^4       # Atomisches Swap (lesen + schreiben)
    SETV %TMP 0|0; NOP^4
    IFR %SIDEVEC %TMP              # Wenn wir nicht an der Seite der Hülle sind, ...
      JMPI CONTINUE_WRITEFORWARD; NOP^4 # ... dann normale Zeile schreiben

    # Hüllen Seite schreiben (auch defensiv)
    IFFR %SIDEVEC                  # Ist die Seitenzelle FREMD?
      JMPI CONTINUE_CLEANUP_STACK; NOP^4 # ... dann abbrechen (Stack enthält noch SHELL + Moleküle)

    INPR %SIDEVEC                  # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %SIDEVEC; NOP^4    # ... dann lösche ich es
    POKE %SHELL %SIDEVEC; NOP^4

  CONTINUE_WRITEFORWARD:
    SEEK %DIRVEC; NOP^4            # Vorwärts
    JMPI CONTINUE_WRITELINE; NOP^4; JMPI CONTINUE_WRITELINE

  .ORG 0|13 # weiter
  CONTINUE_WRITEFINISH:            # Hüllenabschluss schreiben, zurück zum Anfang und zur nächsten Zeile
    # Defensive Prüfung vor PEEK
    IFFR %DIRVEC                   # Ist die Zelle FREMD?
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^4 # ... dann abbrechen
    INPR %DIRVEC                   # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %DIRVEC; NOP^4     # ... dann lösche ich es
    SETV %TMP 0|0; NOP^4
    IFR %SIDEVEC %TMP              # Wenn wir nicht an der Seite der Hülle sind, ...
      JMPI CONTINUE_WRITE_FINISH_END; NOP^4 # ... dann normale Zeile schreiben
    # Hüllen Seite schreiben (auch defensiv)
    IFFR %SIDEVEC                  # Ist die Seitenzelle FREMD?
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^4 # ... dann abbrechen
    INPR %SIDEVEC                  # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %SIDEVEC; NOP^4    # ... dann lösche ich es
    POKE %SHELL %SIDEVEC; NOP^3
    JMPI CONTINUE_WRITE_FINISH_END; NOP^3; JMPI CONTINUE_WRITE_FINISH_END

  .ORG 0|14
  CONTINUE_WRITE_FINISH_END:
    # Defensive Prüfung vor PEEK und POKE
    IFFR %DIRVEC                   # Ist die Zelle FREMD?
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP # ... dann abbrechen
    INPR %DIRVEC                   # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %DIRVEC; NOP^4     # ... dann lösche ich es
    POKE %SHELL %DIRVEC; NOP^4     # Hüllenabschluss der Zeile schreiben
    SETV %TMP 0|0; NOP^4
    IFR %SIDEVEC %TMP              # Wenn wir nicht an der Seite der Hülle sind, ...
      JMPI CONTINUE_WRITEFINISH_NOSIDE; NOP^4 # ... dann normale Zeileabschluss schreiben
    JMPI CONTINUE_WRITEFINISH_CORNER; NOP^4; JMPI CONTINUE_WRITEFINISH_CORNER

  .ORG 0|15
  CONTINUE_WRITEFINISH_CORNER:
    # Ecke schreiben
    SEEK %DIRVEC; NOP^4              # Vorwärts
    # Defensive Prüfung vor PEEK und POKE
    IFFR %SIDEVEC                  # Ist die Seitenzelle FREMD?
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^4 # ... dann abbrechen
    INPR %SIDEVEC                  # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %SIDEVEC; NOP^4    # ... dann lösche ich es
    POKE %SHELL %SIDEVEC; NOP^4

    # Wenn %SIDEVEC links, dann ist alles kopiert und wir können zum FORK
    CRSR %TMP %DIRVEC %SIDEVEC; NOP^4 # X-Produkt ist 1, wenn %SIDEVEC nach rechts zeigt
    GTI %TMP DATA:0                # Wenn X-Produkt > 0, ...
      JMPI CONTINUE_FORK; NOP^4      # ... dann mit FORK beginnen
    JMPI CONTINUE_WRITEFINISH_NOSIDE; NOP^4; JMPI CONTINUE_WRITEFINISH_NOSIDE

  .ORG 0|16
  CONTINUE_WRITEFINISH_NOSIDE:
    SETV %SIDEVEC 0|0;NOP^4        # Es ist mindestens eine Zeile geschrieben, wir sind also nicht mehr in der ersten
    SKLR %CONTCORD; NOP^4          # Zurück zum Anfang

    # Eine Zeile nach unten - Defensive Prüfung
    RTRI %DIRVEC DATA:1 DATA:0; NOP^4     # Nach rechts drehen

    IFFR %DIRVEC                   # Ist die Zelle FREMD?
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^4 # ... dthen abbrechen

    INPR %DIRVEC                   # Wenn das Molekül nicht passierbar,...
      PEEK %TMP %DIRVEC; NOP^4     # ... dthen lösche ich es
    SEEK %DIRVEC; NOP^4            # Vorwärts
    JMPI CONTINUE_WRITEFINISH_NOSIDE2; NOP^12; JMPI CONTINUE_WRITEFINISH_NOSIDE2

    .ORG 0|17
    CONTINUE_WRITEFINISH_NOSIDE2:
    SCAN %TMP %DIRVEC; NOP^4       # Was ist vor uns (nach unten)?
    IFR %TMP %SHELL                # Ist das die Hülle?...
      SETR %SIDEVEC %DIRVEC;NOP^4  # ... Dann sind wir in der Ecke und müssen und das mit %SIDEVEC merken

    RTRI %DIRVEC DATA:0 DATA:1;NOP^4 # Nach links drehen -> Reproduktionsrichtung
    DPLR %CONTCORD; NOP^4          # Continue-Position erreicht -> speichern

    # DP0 und DP1 wiederherstellen
    ADPI DATA:1; NOP^4
    SKLS; NOP^4
    ADPI DATA:0; NOP^4
    SKLS; NOP^4                      # Mutations-Puffer vor kritischem Sprung
    JMPI CONTINUE_LOOP; NOP^4; JMPI CONTINUE_LOOP

  .ORG 0|18
  CONTINUE_FORK:

    RTRI %DIRVEC DATA:0 DATA:1; NOP^4     # Richtung nach innen drehen zum schreiben
    RTRI %DIRVEC DATA:0 DATA:1; NOP^4
    SEEK %DIRVEC; NOP^4            # Einen schritt vorwärt um innerhalb der Hülle zu sein
  # So lange nach Norden laufen,  bis ich an der Hülle bin
  CONTINUE_FORK_NORTH:
    SCNI %TMP 0|-1; NOP^4          # Was liegt nördlich?
    IFR %TMP %SHELL                # Ist das die Hülle?
      JMPI CONTINUE_FORK_WEST; NOP^4 # ... Dann nach Westen laufen
    SEKI 0|-1; NOP                 # Sonst einen Schritt nach Norden
    JMPI CONTINUE_FORK_NORTH; NOP^8; JMPI CONTINUE_FORK_NORTH

  .ORG 0|19
  # So lange nach Westen laufen, bis ich an der Hülle bin
  CONTINUE_FORK_WEST:
    SCNI %TMP -1|0; NOP^4          # Was liegt westlich?
    IFR %TMP %SHELL                # Ist das die Hülle?
      JMPI CONTINUE_FORK_FINISH; NOP^4 # ... Dann FORKen
    SEKI -1|0; NOP^4               # Sonst einen Schritt nach Westen
    JMPI CONTINUE_FORK_WEST; NOP^27; JMPI CONTINUE_FORK_WEST

  # FORK ausführen
  .ORG 0|20
  CONTINUE_FORK_FINISH:
    SEKI -1|0; NOP^4               # Einen Schritt nach Westen
    PUSV 1|0; NOP^4                # Die obere linke Ecke des Kindes liegt im Osten
    PUSI REPRODUCTION_CHILD_INITAL_ENERGY; NOP^2 # Energie für das Kind auf den DS legen
    GDVS; NOP^4                    # Kind bekommt selbe DV Richtung wie Elternorganismus
    FRKS; NOP^4                 # FORKen, Alle 3 Werte werden vom Stack entfernt
    JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^25; JMPI CONTINUE_PREP_NEXT_REPRODUCTION

  .ORG 0|21
  # Stack-Cleanup für Abbrüche während WRITELINE (wo SHELL noch auf dem Stack liegt)
  # Wird aufgerufen von Abbrüchen in CONTINUE_WRITELINE (Zeilen 183-184, 195-196)
  CONTINUE_CLEANUP_STACK:
    POP %TMP;NOP^4                   # Molekül vom DS holen
    IFR %TMP %SHELL                  # Ist es das SHELL-Terminator-Symbol?
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^4 # Ja -> fertig mit Stack-Cleanup
    IFR %TMP %SHELL                  # Redundanz
      JMPI CONTINUE_PREP_NEXT_REPRODUCTION; NOP^4
    JMPI CONTINUE_CLEANUP_STACK; NOP^4; JMPI CONTINUE_CLEANUP_STACK;      # Nein -> weiter poppen

  .ORG 0|22
  CONTINUE_PREP_NEXT_REPRODUCTION:
    # Aufräumen und fertig - ROBUST gegen vorzeitigen Abbruch
    CMRI DATA:1; NOP^4             # Alte Marker löschen, damit abgebrochene Moleküle nicht bei FORK übertragen werden
    RTRI %DIRVEC DATA:0 DATA:1     # %DIRVEC wieder nach außen drehen
    RTRI %DIRVEC DATA:0 DATA:1; NOP^4

    # Setze %SIDEVEC auf links für neue Reproduktion
    SETR %SIDEVEC %DIRVEC          # Kopiere %DIRVEC
    RTRI %SIDEVEC DATA:0 DATA:1; NOP^4 # Rotiere 90° CCW = links relativ zu %DIRVEC

    SETI %DIRMASK DATA:0           # Beim nächsten Mal wird eine Richtung neu zufällig gewählt
    CRLR %CONTCORD; NOP^4          # Beim nächsten Mal brauchen wir eine leere Zeilen Koordinate, damit von vorne begonnen wird
    #CRLR %FORKCORD                 # Auch die Koordinate für das FORK muss neu berechnet werden

    # DP0 und DP1 wiederherstellen
    ADPI DATA:1; NOP^4
    SKLS; NOP^4
    ADPI DATA:0; NOP^4
    SKLS; NOP^4
    JMPI CONTINUE_SAVE_AND_RET; NOP^4; JMPI CONTINUE_SAVE_AND_RET

  .ORG 0|23
  CONTINUE_SAVE_AND_RET:
    SKLS; NOP^4                                   # alten DP wiederherstellen

    SETV %TMP 0|0; NOP^4
    IFR %SIDEVEC %TMP                             # Für Mittelzeile sind wir fertig
      JMPI CONTINUE_SIDVEC_STORE_0; NOP^4

    CRSR %SIDEVEC %DIRVEC %SIDEVEC; NOP^4         # X-Produkt gibt 1 für rechts und -1 für links
    JMPI CONTINUE_STORE_STATE; NOP^20; JMPI CONTINUE_STORE_STATE

  .ORG 0|24
  CONTINUE_SIDVEC_STORE_0:
    SETI %SIDEVEC DATA:0; NOP^4                   # Mutations-Puffer

  CONTINUE_STORE_STATE:
    SMRI DATA:0; NOP^4                            # Marker zurücksetzen vor Rückkehr
    # vor RET: "in einem Rutsch" speichern
    STATIC2_STORE CONTINUE_STATE %DIRMASK %SIDEVEC; NOP^4
    JMPI CONTINUE_STORE_STATE2; NOP^10; JMPI CONTINUE_STORE_STATE2

  .ORG 0|25
  CONTINUE_STORE_STATE2:
    NOP^8; RET; NOP^20; RET; NOP^4; RET
.ENDP