# lib/energy.evo
# Exportierte Energiesuche: ballistisch + periodischer Turn mit Primperioden.

.INCLUDE "lib/state.evo"
.REQUIRE "lib/state.evo" AS STATE

.ORG 0|0
.PROC HARVEST EXPORT

  .PREG %FWD_MASK %PR0   # cached forward direction as bitmask
  .PREG %KIDX     %PR1   # index 0..3 for K-periods
  .PREG %KLEFT    %PR2   # countdown to periodic turn
  .PREG %DIR      %PR3   # movement direction vector (neu bei jedem Aufruf)
  .PREG %MASK     %PR4   # Bitmaske von SNTI/SPNR
  .PREG %VEC      %PR5   # temporärer Richtungsvektor

  
  NOP; JMPI HARVEST_START; NOP^53; JMPI HARVEST_START

  # 3 DATA-Felder in der Zeile über HARVEST_START (x=0..2, y=-1 relativ zu HARVEST_START)
  .PLACE DATA:1  0|1    # FWD_MASK: rechts (Bitmaske)
  .PLACE DATA:0  1|1    # KIDX: Index 0
  .PLACE DATA:89 2|1    # KLEFT: K0-Periode

  .ORG 0|2
    HARVEST_START:
      # am Anfang: "in einem Rutsch" laden
      STATIC3_LOAD %FWD_MASK %KIDX %KLEFT; NOP^2
      JMPI HARVEST_RANDOM_DIR

    .ORG 0|3
    HARVEST_RANDOM_DIR: NOP^2
      # Zufällige Richtung wählen (NACH dem State-Load!)
      SPNR %MASK; NOP^4             # %MASK := passierbare Richtungen (Bitmaske)
      IFI %MASK DATA:0                 # Prüfe ob überhaupt eine Richtung passierbar ist
        JMPI HARVEST_STUCK; NOP^4        # Wenn nicht, zurück zum IP
      RBIR %DIR %MASK; NOP^4
      B2VR %DIR %DIR; NOP^4
      V2BR %FWD_MASK %DIR; NOP^4
      JMPI HARVEST_LOOP; NOP^15; JMPI HARVEST_LOOP

    .ORG 0|4
    HARVEST_LOOP: NOP^4
      # 1) Umgebung scannen – wenn Energie da, sofort nehmen und zurück
      SNTI %MASK ENERGY:0; NOP^2
      IFI %MASK DATA:0
        JMPI HARVEST_MOVE; NOP^2

      RBIR %VEC %MASK; NOP^2
      B2VR %VEC %VEC; NOP^2

      SCAN %MASK %VEC; NOP^2
      LETI %MASK ENERGY:0
        JMPI HARVEST_MOVE; NOP^2

      PEEK %MASK %VEC; NOP^2
      JMPI HARVEST_SAVE_AND_RETURN; NOP^9; JMPI HARVEST_SAVE_AND_RETURN

    .ORG 0|5
    HARVEST_SAVE_AND_RETURN:
      # vor RET: "in einem Rutsch" speichern
      STATIC3_STORE %FWD_MASK %KIDX %KLEFT
      JMPI HARVEST_SAVE_AND_RETURN2; NOP^6; JMPI HARVEST_SAVE_AND_RETURN2

    .ORG 0|6
    HARVEST_SAVE_AND_RETURN2: NOP^2
      NOP^4; RET; NOP^4; RET; NOP^3

    HARVEST_STUCK:
      # Keine Richtung passierbar: zurück zum IP und neu starten
      SYNC; NOP^4                    # Setzt DP = IP
      JMPI HARVEST_START; NOP^34; JMPI HARVEST_START

    .ORG 0|7
    HARVEST_MOVE: NOP^2
      # 2) Vorwärts passierbar?
      SPNR %MASK; NOP^4
      IFI %MASK DATA:0                  # Prüfe ob überhaupt eine Richtung passierbar ist
        JMPI HARVEST_STUCK; NOP^4       # Wenn nicht, zurück zum IP
      ANDR %MASK %FWD_MASK; NOP^4
      IFI %MASK DATA:0
        JMPI HARVEST_TURN; NOP^2

      # 3) Schritt vorwärts
      SEEK %DIR; NOP^4

      # 4) Periodischer Turn-Countdown
      DECR %KLEFT; NOP^5
      IFI  %KLEFT DATA:0
        JMPI HARVEST_TURN; NOP^5
      JMPI HARVEST_LOOP

    .ORG 0|8
    HARVEST_TURN: NOP^2
      # 90° CW drehen (Achsen 0,1) ohne externe Temp-Register
      RTRI %DIR DATA:0 DATA:1; NOP^4
      V2BR %FWD_MASK %DIR; NOP^4

      # KIDX = (KIDX+1) mod 4
      INCR %KIDX; NOP^5
      GTI  %KIDX DATA:3
        JMPI HARVEST_PT_WRAP; NOP^4
      JMPI HARVEST_PT_LOAD; NOP^4

    HARVEST_PT_WRAP: NOP^4
      SETI %KIDX DATA:0; NOP^4
      JMPI HARVEST_PT_LOAD; NOP^2; JMPI HARVEST_PT_LOAD

    .ORG 0|9
    HARVEST_PT_LOAD: NOP^4
      # Nächste Prim-Periode auswählen und KLEFT laden
      IFI %KIDX DATA:0
        JMPI HARVEST_PT_K0; NOP^4
      IFI %KIDX DATA:1
        JMPI HARVEST_PT_K1; NOP^4
      IFI %KIDX DATA:2
        JMPI HARVEST_PT_K2; NOP^4
      # else K3
      SETI %KLEFT DATA:103; NOP^4
      JMPI HARVEST_LOOP; NOP^13; JMPI HARVEST_LOOP

    .ORG 0|10
    HARVEST_PT_K0: NOP^4
      SETI %KLEFT DATA:89; NOP^4
      JMPI HARVEST_LOOP

    HARVEST_PT_K1: NOP^4
      SETI %KLEFT DATA:97; NOP^4
      JMPI HARVEST_LOOP; NOP^4

    HARVEST_PT_K2: NOP^4
      SETI %KLEFT DATA:101; NOP^4
      JMPI HARVEST_LOOP; NOP^4

    # Safety-Jumps am Ende der Prozedur (falls Code durch Mutation hierher fällt)
    NOP; JMPI HARVEST_LOOP; NOP^3; JMPI HARVEST_LOOP
.ENDP