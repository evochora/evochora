syntax = "proto3";

package org.evochora.datapipeline.api.contracts;

import "org/evochora/datapipeline/api/contracts/metadata_contracts.proto";

option java_multiple_files = true;
option java_package = "org.evochora.datapipeline.api.contracts";

// ============================================================================
// Tick Data (sent every sampled tick)
// ============================================================================

// Represents the complete state of the simulation at a specific tick.
// This message is sent every N ticks (where N is the sampling interval).
// It contains everything needed to checkpoint and resume the simulation.
message TickData {
  // Unique identifier matching SimulationMetadata.simulation_run_id
  // Used to correlate tick data with metadata
  string simulation_run_id = 1;

  // The current tick number (0-indexed)
  // Source: SimulationEngine's tick counter
  int64 tick_number = 2;

  // System timestamp when this tick was captured (milliseconds since epoch)
  // Created via: System.currentTimeMillis()
  int64 capture_time_ms = 3;

  // All organisms at this tick, including dead organisms awaiting final serialization.
  // Dead organisms appear once with is_dead=true and death_tick set, then are pruned from memory.
  // Created by: iterating over all organisms and converting to OrganismState messages
  repeated OrganismState organisms = 4;

  // All non-empty cells in the environment (sparse representation)
  CellDataColumns cell_columns = 5;

  // Complete RNG state for checkpoint/resume
  // Created via: IRandomProvider.saveState()
  // For Well19937c: serialized int[] v array (624 ints) + index (1 int)
  bytes rng_state = 6;

  // State of all tick plugins (for checkpoint/resume)
  // Created by: calling ISerializable.saveState() on each active plugin
  // Example: GeyserCreator serializes geyser locations
  repeated PluginState plugin_states = 7;

  // Total number of organisms ever created in this simulation run.
  // This is a monotonic counter that includes both initial and child organisms.
  // Used by analytics to derive death counts (TotalBorn - Alive = TotalDead).
  // Source: SimulationEngine.totalOrganismsCreated
  int64 total_organisms_created = 8;

  // Total number of unique genomes ever observed in this simulation run.
  // This is a monotonic counter tracking genome diversity over time.
  // Source: Simulation.getTotalUniqueGenomesCount()
  int64 total_unique_genomes = 9;

  // Complete set of all genome hashes ever observed (for checkpoint/resume).
  // Only meaningful in snapshots (not stored in TickDelta).
  // On resume from old simulations where this is empty, the set is
  // reconstructed from living organisms' genome hashes (losing extinct genomes).
  // Source: Simulation.getAllGenomesEverSeen()
  repeated int64 all_genome_hashes_ever_seen = 10 [packed=true];
}

// Represents the serialized state of a tick plugin
message PluginState {
  // Fully qualified class name of the plugin
  // Example: "org.evochora.runtime.worldgen.GeyserCreator"
  string plugin_class = 1;

  // Plugin-specific serialized state
  // Created via: ISerializable.saveState() implementation
  // Stateless plugins (e.g., SolarRadiationCreator) return empty bytes
  // Stateful plugins (e.g., GeyserCreator) serialize their configuration
  bytes state_blob = 2;
}

// ============================================================================
// Organism State
// ============================================================================

// Represents the complete state of an organism at a specific tick.
// Maps to org.evochora.runtime.model.Organism class.
// All fields are directly accessible via Organism getter methods.
message OrganismState {
  // Unique identifier for this organism within the simulation
  // Source: Organism.getId()
  int32 organism_id = 1;

  // ID of the parent organism (if this organism was created via replication)
  // Source: Organism.getParentId()
  // Set to absent if the organism was created at initialization
  optional int32 parent_id = 2;

  // Tick number when this organism was born
  // Source: Organism.getBirthTick()
  int64 birth_tick = 3;

  // Identifier of the compiled program this organism is executing
  // Source: Organism.getProgramId()
  // Corresponds to ProgramArtifact.program_id in metadata
  string program_id = 4;

  // Current energy level of the organism
  // Source: Organism.getEnergy()
  // Organism dies when energy reaches 0
  int32 energy = 5;

  // ===== Instruction Pointer and Movement =====

  // Current instruction pointer (relative coordinates in program space)
  // Source: Organism.getIp()
  // This is where the organism is currently executing in its program
  Vector ip = 6;

  // Position where the organism started executing
  // Source: Organism.getInitialPosition()
  // Used to calculate absolute positions from relative coordinates
  Vector initial_position = 7;

  // Direction vector for IP movement
  // Source: Organism.getDv()
  // Determines how the IP advances after each instruction
  Vector dv = 8;

  // Data pointer locations (relative coordinates)
  // Source: Organism.getDataPointers()
  // Organisms can have multiple data pointers for memory access
  repeated Vector data_pointers = 9;

  // Index of the currently active data pointer
  // Source: Organism.getActiveDpIndex()
  // Determines which data_pointers entry is used for data operations
  int32 active_dp_index = 10;

  // ===== Registers =====

  // Data registers (DRs) - general purpose scalar/vector registers
  // Source: Organism.getDataRegisters()
  // Used for arithmetic and data manipulation
  repeated RegisterValue data_registers = 11;

  // Procedure registers (PRs) - used for procedure-local variables
  // Source: Organism.getProcedureRegisters()
  // Saved/restored during procedure calls
  repeated RegisterValue procedure_registers = 12;

  // Formal parameter registers (FPRs) - used for procedure parameters
  // Source: Organism.getFormalParamRegisters()
  // Mapped to actual parameters during procedure calls
  repeated RegisterValue formal_param_registers = 13;

  // Location registers (LRs) - store coordinate vectors
  // Source: Organism.getLocationRegisters()
  // Used for spatial operations and addressing
  repeated Vector location_registers = 14;

  // ===== Stacks =====

  // Data stack for temporary scalar/vector values
  // Source: Organism.getDataStack()
  repeated RegisterValue data_stack = 15;

  // Location stack for temporary coordinate vectors
  // Source: Organism.getLocationStack()
  repeated Vector location_stack = 16;

  // Call stack for procedure invocations
  // Source: Organism.getCallStack()
  // Each frame stores return address and saved register state
  repeated ProcFrame call_stack = 17;

  // ===== Status =====

  // Whether the organism is dead
  // Source: Organism.isDead()
  // Dead organisms may be included in tick data if they died during the tick
  bool is_dead = 18;

  // Whether the last instruction execution failed
  // Source: Organism.isInstructionFailed()
  bool instruction_failed = 19;

  // Human-readable reason for instruction failure
  // Source: Organism.getFailureReason()
  // Only present if instruction_failed is true
  optional string failure_reason = 20;

  // Call stack at the time of failure (for debugging)
  // Source: Organism.getFailureCallStack()
  // Only present if instruction_failed is true
  repeated ProcFrame failure_call_stack = 21;

  // ===== Instruction Execution Data =====

  // Opcode ID of the last executed instruction
  // Source: InstructionExecutionData.opcodeId
  // Only present if an instruction was executed in this tick
  optional int32 instruction_opcode_id = 22;

  // Raw argument values from the environment for the last executed instruction
  // Source: InstructionExecutionData.rawArguments
  // Only present if an instruction was executed in this tick
  repeated int32 instruction_raw_arguments = 23;

  // Total energy cost for executing the last instruction
  // Source: InstructionExecutionData.energyCost
  // Only present if an instruction was executed in this tick
  optional int32 instruction_energy_cost = 24;

  // Total entropy delta for executing the last instruction
  // Source: InstructionExecutionData.entropyDelta
  // Only present if an instruction was executed in this tick
  // Positive values = entropy generation, negative values = entropy dissipation
  optional int32 instruction_entropy_delta = 25;

  // Instruction pointer position at the beginning of the tick (before instruction execution)
  // Source: Organism.getIpBeforeFetch()
  // Used to reconstruct the position of the instruction in the program
  Vector ip_before_fetch = 26;

  // Direction vector at the beginning of the tick (before instruction execution)
  // Source: Organism.getDvBeforeFetch()
  // Used to reconstruct the position of the instruction in the program
  Vector dv_before_fetch = 27;
  
  // Register values before instruction execution (for annotation display)
  // Maps register ID to RegisterValue (only for registers used as arguments)
  // Key: register ID (int32), Value: RegisterValue
  // Source: InstructionExecutionData.registerValuesBefore
  // Only present if an instruction was executed in this tick
  map<int32, RegisterValue> instruction_register_values_before = 28;

  // ===== Special Registers =====

  // Entropy register (SR) - read-only register for randomness
  // Source: Organism.getSr()
  int32 entropy_register = 29;

  // Molecule marker register (MR) - determines marker value for written molecules
  // Source: Organism.getMr()
  // Value range: 0-15 (4 bits)
  int32 molecule_marker_register = 30;

  // Genome hash computed at birth from CODE, LABEL, LABELREF, REGISTER, STRUCTURE, ENERGY molecules
  // Source: Organism.getGenomeHash()
  // Uniquely identifies the organism's genetic material independent of position
  // Value is 0 if the organism has no genome molecules (empty genome)
  int64 genome_hash = 31;

  // Tick number when this organism died (-1 or absent if still alive)
  // Source: Organism.getDeathTick()
  // Only present for dead organisms included in their final serialization
  optional int64 death_tick = 32;
}

// Aggregated runtime state for organism indexing.
// Used by OrganismIndexer to store sidebar-only data in a single BLOB.
message OrganismRuntimeState {
  repeated RegisterValue data_registers = 1;
  repeated RegisterValue procedure_registers = 2;
  repeated RegisterValue formal_param_registers = 3;
  repeated Vector        location_registers = 4;
  repeated RegisterValue data_stack = 5;
  repeated Vector        location_stack = 6;
  repeated ProcFrame     call_stack = 7;
  bool                   instruction_failed = 8;
  string                 failure_reason = 9;
  repeated ProcFrame     failure_call_stack = 10;
  
  // ===== Instruction Execution Data =====
  
  // Opcode ID of the last executed instruction
  // Source: InstructionExecutionData.opcodeId
  // Only present if an instruction was executed in this tick
  optional int32 instruction_opcode_id = 11;
  
  // Raw argument values from the environment for the last executed instruction
  // Source: InstructionExecutionData.rawArguments
  // Only present if an instruction was executed in this tick
  repeated int32 instruction_raw_arguments = 12;
  
  // Total energy cost for executing the last instruction
  // Source: InstructionExecutionData.energyCost
  // Only present if an instruction was executed in this tick
  optional int32 instruction_energy_cost = 13;
  
  // Total entropy delta for executing the last instruction
  // Source: InstructionExecutionData.entropyDelta
  // Only present if an instruction was executed in this tick
  // Positive values = entropy generation, negative values = entropy dissipation
  optional int32 instruction_entropy_delta = 31;
  
  // Instruction pointer position at the beginning of the tick (before instruction execution)
  // Source: Organism.getIpBeforeFetch()
  // Used to reconstruct the position of the instruction in the program
  optional Vector instruction_ip_before_fetch = 14;
  
  // Direction vector at the beginning of the tick (before instruction execution)
  // Source: Organism.getDvBeforeFetch()
  // Used to reconstruct the position of the instruction in the program
  optional Vector instruction_dv_before_fetch = 15;
  
  // Register values before instruction execution (for annotation display)
  // Maps register ID to RegisterValue (only for registers used as arguments)
  // Key: register ID (int32), Value: RegisterValue
  // Source: InstructionExecutionData.registerValuesBefore
  // Only present if an instruction was executed in this tick
  map<int32, RegisterValue> instruction_register_values_before = 16;

  // ===== Special Registers =====

  // Entropy register (SR) - read-only register for randomness
  // Source: Organism.getSr()
  int32 entropy_register = 17;

  // Molecule marker register (MR) - determines marker value for written molecules
  // Source: Organism.getMr()
  // Value range: 0-15 (4 bits)
  int32 molecule_marker_register = 18;

  // Whether the organism is dead (for RowPerOrganismStrategy runtime blob)
  bool is_dead = 19;

  // Tick number when this organism died (-1 or absent if still alive)
  optional int64 death_tick = 20;
}

// Wrapper for encoding all data pointers in one column for indexing.
message DataPointerList {
  repeated Vector data_pointers = 1;
}

// Represents a procedure call frame on the call stack.
// Maps to org.evochora.runtime.model.ProcFrame class.
// Captures the state needed to return from a procedure call.
message ProcFrame {
  // Name of the procedure being called
  // Source: ProcFrame.getProcName()
  string proc_name = 1;

  // Absolute return address (where to resume after procedure returns)
  // Source: ProcFrame.getAbsoluteReturnIp()
  // Stored as absolute coordinates, not relative to program
  Vector absolute_return_ip = 2;

  // Saved procedure registers (PRs) from caller's context
  // Source: ProcFrame.getSavedPrs()
  // Restored when procedure returns
  repeated RegisterValue saved_prs = 3;

  // Saved formal parameter registers (FPRs) from caller's context
  // Source: ProcFrame.getSavedFprs()
  // Restored when procedure returns
  repeated RegisterValue saved_fprs = 4;

  // Mapping from formal parameter index to actual parameter value
  // Source: ProcFrame.getFprBindings()
  // Key: FPR index, Value: actual parameter value
  map<int32, int32> fpr_bindings = 5;

  // Absolute address of the CALL instruction that created this frame
  // Source: ProcFrame.getAbsoluteCallIp()
  // Stored as absolute coordinates, not relative to program
  // Used for resolving parameter bindings from artifact at debug time
  // This allows the frontend to look up callSiteBindings using the CALL instruction address
  Vector absolute_call_ip = 6;
}

// Represents a register value that can be either scalar or vector.
// This polymorphic type is used for data registers, procedure registers,
// formal parameter registers, and stack values.
message RegisterValue {
  oneof value {
    // Scalar integer value
    // Source: RegisterValue containing a scalar int
    int32 scalar = 1;

    // Vector (coordinate) value
    // Source: RegisterValue containing a vector
    Vector vector = 2;
  }
}

// ============================================================================
// Cell State
// ============================================================================

// Columnar storage format for cell data.
message CellDataColumns {
  // Parallel array of flat indices (must be same length as molecule_data and owner_ids)
  repeated int32 flat_indices = 1 [packed=true];
  
  // Parallel array of molecule data (packed int32: type, value, marker)
  repeated int32 molecule_data = 2 [packed=true];
  
  // Parallel array of owner IDs
  repeated int32 owner_ids = 3 [packed=true];
}

// Represents a single cell in the environment grid.
// Maps to org.evochora.runtime.model.Molecule class.
// Only non-empty cells are included (sparse representation).
//
// PERFORMANCE OPTIMIZATION: Uses flat_index instead of coordinate Vector
// - Data size reduction: 80% (20 bytes → 4 bytes per cell coordinate)
// - CPU performance gain: 16% in SimulationEngine.extractCellStates
// - Trade-off: Downstream consumers must convert flat_index back to coordinates
//   using Environment.shape metadata from TickData.metadata
message CellState {
  // Flat index representing the cell's position in the environment grid.
  // This is an OPAQUE identifier that requires Environment properties to interpret.
  //
  // Conversion formula (2D): flatIndex = y * width + x
  // Reverse conversion: x = flatIndex % width, y = flatIndex / width
  //
  // For 3D environments: flatIndex = z * (width * height) + y * width + x
  //
  // Source: Environment.forEachOccupiedIndex() callback parameter
  // Required metadata: Environment.shape from TickData.metadata
  int32 flat_index = 1;

  // COMMENTED OUT: Previous coordinate-based approach for easy migration
  // If performance/size trade-off becomes unfavorable, uncomment this field
  // and update SimulationEngine.extractCellStates to use coordinate version.
  //
  // Vector coordinate = 1;

  // Combined molecule data using bitmask (type, value, marker).
  // This is the packed int32 from the internal Molecule class.
  // Use masks and shifts from org.evochora.runtime.Config to decode.
  int32 molecule_data = 2;

  // ID of the organism that owns this cell (0 if unowned)
  // Source: Molecule.getOwnerId()
  // Used to track which organism's program occupies this cell
  int32 owner_id = 4;
}


// Wrapper message for efficient BLOB storage of organism states in databases.
// Used by SingleBlobOrgStrategy to serialize organism lists for compact storage.
//
// USAGE:
// - Write: OrganismStateList.newBuilder().addAllOrganisms(tick.getOrganismsList()).build().toByteArray()
// - Read: OrganismStateList.parseFrom(blob).getOrganismsList()
//
// RATIONALE: Row-per-organism-per-tick creates millions of rows (100 organisms × 200k ticks = 20M rows).
// BLOB strategy reduces this to 200k rows (one per tick), improving H2 MERGE performance by ~100×.
//
// STORAGE: ~10-50 KB per tick (100 organisms × 500 bytes protobuf + overhead)
// With zstd compression: ~2-10 KB per tick
message OrganismStateList {
  repeated OrganismState organisms = 1;
}

// ============================================================================
// Delta Compression (DELTA_COMPRESSION.md proposal)
// ============================================================================

// Type of delta in a TickDataChunk.
// DELTA_TYPE_UNSPECIFIED (0) is a sentinel for corrupt/uninitialized data.
enum DeltaType {
  DELTA_TYPE_UNSPECIFIED = 0;  // Invalid - should never occur in valid data
  INCREMENTAL = 1;             // Changes since last sampled tick
  ACCUMULATED = 2;             // Changes since last snapshot (checkpoint-capable)
}

// Compact representation of changes between ticks.
// Used within TickDataChunk to store deltas efficiently.
//
// KEY INSIGHT: Environment cells are sparse (only changed cells stored),
// but organisms are always complete (they change almost entirely every tick).
//
// FIELDS BY DELTA TYPE:
// - INCREMENTAL: changed_cells, organisms, total_organisms_created
// - ACCUMULATED: All fields (includes rng_state, strategy_states for checkpointing)
message TickDelta {
  // The tick number this delta represents
  int64 tick_number = 1;

  // System timestamp when this tick was captured (milliseconds since epoch)
  int64 capture_time_ms = 2;

  // Type of delta (INCREMENTAL or ACCUMULATED)
  DeltaType delta_type = 3;

  // Environment: ONLY changed cells since last sample (the big storage win!)
  // For INCREMENTAL: changes since previous sampled tick
  // For ACCUMULATED: changes since last snapshot
  CellDataColumns changed_cells = 4;

  // Organisms: Always complete (small, ~500 bytes per organism)
  // Organisms change almost entirely every tick (IP, energy, registers),
  // so delta tracking overhead would exceed savings.
  repeated OrganismState organisms = 5;

  // Total organisms ever created (monotonic counter for analytics)
  int64 total_organisms_created = 6;

  // RNG state for checkpoint/resume (ACCUMULATED deltas only)
  // Empty for INCREMENTAL deltas.
  bytes rng_state = 7;

  // Plugin states for checkpoint/resume (ACCUMULATED deltas only)
  // Empty for INCREMENTAL deltas.
  repeated PluginState plugin_states = 8;

  // Total unique genomes ever observed (monotonic counter for analytics)
  int64 total_unique_genomes = 9;
}

// Self-contained chunk of tick data for pipeline transmission.
// Contains one full snapshot followed by multiple deltas.
//
// DESIGN RATIONALE:
// - Self-contained: Can be processed by competing consumers without prior state
// - Metadata at top level: PersistenceService can route without parsing content
// - Snapshot first: Enables seeking to any tick within the chunk
//
// TYPICAL CONFIGURATION (100 ticks/chunk):
// - 1 snapshot (~10MB)
// - 19 accumulated deltas (~200KB each, with RNG state)
// - 80 incremental deltas (~50KB each, no RNG state)
// - Total uncompressed: ~25MB, compressed with zstd: ~2.5MB
message TickDataChunk {
  // === Metadata (for PersistenceService routing, no content parsing needed) ===

  // Unique identifier matching SimulationMetadata.simulation_run_id
  string simulation_run_id = 1;

  // First tick number in this chunk (= snapshot tick)
  int64 first_tick = 2;

  // Last tick number in this chunk
  int64 last_tick = 3;

  // Total number of ticks in this chunk (1 snapshot + N deltas)
  int32 tick_count = 4;

  // === Content ===

  // Complete state at first_tick (self-contained, enables any tick reconstruction)
  TickData snapshot = 5;

  // Deltas for subsequent ticks (tick_count - 1 entries)
  // Ordered by tick_number ascending.
  repeated TickDelta deltas = 6;
}