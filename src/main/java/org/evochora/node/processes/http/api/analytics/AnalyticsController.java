package org.evochora.node.processes.http.api.analytics;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.evochora.datapipeline.api.analytics.ManifestEntry;
import org.evochora.datapipeline.api.resources.storage.IAnalyticsStorageRead;
import org.evochora.node.processes.http.api.pipeline.dto.ErrorResponseDto;
import org.evochora.node.spi.IController;
import org.evochora.node.spi.ServiceRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.typesafe.config.Config;

import io.javalin.Javalin;
import io.javalin.http.Context;
import io.javalin.openapi.HttpMethod;
import io.javalin.openapi.OpenApi;
import io.javalin.openapi.OpenApiContent;
import io.javalin.openapi.OpenApiParam;
import io.javalin.openapi.OpenApiResponse;

/**
 * HTTP controller for serving analytics artifacts and manifest.
 * <p>
 * Provides REST API endpoints for discovering and downloading Parquet-based
 * analytics data generated by the AnalyticsIndexer.
 * <p>
 * <strong>Key features:</strong>
 * <ul>
 *   <li>Manifest aggregation (discovers all metric plugins and their metadata)</li>
 *   <li>File listing with optional prefix filter</li>
 *   <li>File streaming for Parquet, JSON, and CSV artifacts</li>
 *   <li>Response caching for manifest (configurable TTL)</li>
 * </ul>
 * <p>
 * <strong>Thread Safety:</strong> This controller is thread-safe and can handle concurrent requests.
 */
public class AnalyticsController implements IController {

    private static final Logger log = LoggerFactory.getLogger(AnalyticsController.class);
    private final IAnalyticsStorageRead storage;
    private final Gson gson = new GsonBuilder().create();
    
    // Caching for Manifest
    private final long cacheTtlMs;
    private final ConcurrentHashMap<String, CacheEntry> manifestCache = new ConcurrentHashMap<>();

    private record CacheEntry(long timestamp, String json) {}

    /**
     * Constructs a new AnalyticsController.
     *
     * @param registry Service registry for accessing storage resources
     * @param options Controller-specific configuration
     */
    public AnalyticsController(ServiceRegistry registry, Config options) {
        this.storage = registry.get(IAnalyticsStorageRead.class);
        this.cacheTtlMs = options.hasPath("analyticsManifestCacheTtlSeconds") 
            ? options.getInt("analyticsManifestCacheTtlSeconds") * 1000L 
            : 30000L; // Default 30s
    }

    @Override
    public void registerRoutes(Javalin app, String basePath) {
        app.get(basePath + "/manifest", this::getManifest);
        app.get(basePath + "/list", this::listFiles);
        app.get(basePath + "/files/<path>", this::getFile);
    }

    /**
     * Lists analytics files for a simulation run.
     * <p>
     * Route: GET /list?runId=...&amp;prefix=...
     *
     * @param ctx Javalin request context
     */
    @OpenApi(
        path = "list",
        methods = {HttpMethod.GET},
        summary = "List analytics files",
        description = "Returns a list of all analytics artifact files for a simulation run, "
            + "optionally filtered by prefix. Useful for discovering available Parquet files "
            + "for a specific metric or LOD level.",
        tags = {"analyzer / analytics"},
        queryParams = {
            @OpenApiParam(
                name = "runId", 
                description = "Simulation run ID", 
                required = true,
                example = "20251201-143025-550e8400-e29b-41d4-a716-446655440000"
            ),
            @OpenApiParam(
                name = "prefix", 
                description = "Optional path prefix filter (e.g., 'population/lod0')", 
                required = false,
                example = "population/lod0"
            )
        },
        responses = {
            @OpenApiResponse(
                status = "200", 
                description = "List of file paths relative to analytics root",
                content = @OpenApiContent(
                    from = String[].class,
                    example = """
                        [
                          "population/metadata.json",
                          "population/lod0/000/000/batch_00000000000000000000_00000000000000000999.parquet",
                          "population/lod0/000/000/batch_00000000000000001000_00000000000000001999.parquet"
                        ]
                        """
                )
            ),
            @OpenApiResponse(
                status = "400", 
                description = "Bad request (missing runId)", 
                content = @OpenApiContent(from = ErrorResponseDto.class)
            ),
            @OpenApiResponse(
                status = "500", 
                description = "Internal server error", 
                content = @OpenApiContent(from = ErrorResponseDto.class)
            )
        }
    )
    private void listFiles(Context ctx) {
        String runId = ctx.queryParam("runId");
        String prefix = ctx.queryParam("prefix"); // Optional

        if (runId == null || runId.isBlank()) {
            ctx.status(400).result("Missing runId parameter");
            return;
        }

        try {
            List<String> files = storage.listAnalyticsFiles(runId, prefix != null ? prefix : "");
            ctx.json(files);
        } catch (Exception e) {
            log.warn("Failed to list analytics files for run {}", runId, e);
            ctx.status(500).result("Failed to list files");
        }
    }

    /**
     * Returns the aggregated manifest for all analytics plugins.
     * <p>
     * Route: GET /manifest?runId=...
     * <p>
     * The manifest is cached for a configurable TTL to reduce storage reads.
     *
     * @param ctx Javalin request context
     */
    @OpenApi(
        path = "manifest",
        methods = {HttpMethod.GET},
        summary = "Get analytics manifest",
        description = "Returns an aggregated manifest describing all available analytics metrics "
            + "for a simulation run. The manifest includes metadata from each plugin (name, "
            + "description, data sources, visualization hints). Response is cached.",
        tags = {"analyzer / analytics"},
        queryParams = {
            @OpenApiParam(
                name = "runId", 
                description = "Simulation run ID", 
                required = true,
                example = "20251201-143025-550e8400-e29b-41d4-a716-446655440000"
            )
        },
        responses = {
            @OpenApiResponse(
                status = "200", 
                description = "Aggregated manifest with all available metrics",
                content = @OpenApiContent(
                    from = Map.class,
                    example = """
                        {
                          "metrics": [
                            {
                              "id": "population",
                              "name": "Population Overview",
                              "description": "Overview of alive organisms, total deaths, and average energy over time.",
                              "dataSources": {
                                "lod0": "population/lod0/**/*.parquet"
                              },
                              "visualization": {
                                "type": "line-chart",
                                "config": {
                                  "x": "tick",
                                  "y": ["alive_count", "total_dead"],
                                  "y2": ["avg_energy"]
                                }
                              }
                            }
                          ]
                        }
                        """
                )
            ),
            @OpenApiResponse(
                status = "400", 
                description = "Bad request (missing runId)", 
                content = @OpenApiContent(from = ErrorResponseDto.class)
            ),
            @OpenApiResponse(
                status = "500", 
                description = "Internal server error", 
                content = @OpenApiContent(from = ErrorResponseDto.class)
            )
        }
    )
    private void getManifest(Context ctx) {
        String runId = ctx.queryParam("runId");
        if (runId == null || runId.isBlank()) {
            ctx.status(400).result("Missing runId parameter");
            return;
        }

        // Check Cache
        CacheEntry entry = manifestCache.get(runId);
        if (entry != null && (System.currentTimeMillis() - entry.timestamp < cacheTtlMs)) {
            ctx.contentType("application/json").result(entry.json);
            return;
        }

        // Rebuild Manifest
        try {
            List<String> files = storage.listAnalyticsFiles(runId, "");
            List<ManifestEntry> entries = new ArrayList<>();

            for (String file : files) {
                if (file.endsWith("metadata.json")) {
                    try (InputStream in = storage.openAnalyticsInputStream(runId, file)) {
                        String json = new String(in.readAllBytes(), StandardCharsets.UTF_8);
                        ManifestEntry manifestEntry = gson.fromJson(json, ManifestEntry.class);
                        entries.add(manifestEntry);
                    } catch (Exception e) {
                        log.warn("Failed to read/parse metadata file: {}", file, e);
                    }
                }
            }

            Map<String, Object> response = Map.of("metrics", entries);
            String responseJson = gson.toJson(response);
            
            // Update Cache
            manifestCache.put(runId, new CacheEntry(System.currentTimeMillis(), responseJson));
            
            ctx.json(response);
            
        } catch (Exception e) {
            log.error("Failed to aggregate manifest for run {}", runId, e);
            ctx.status(500).result("Failed to generate manifest");
        }
    }

    /**
     * Streams an analytics file to the client.
     * <p>
     * Route: GET /files/{path}?runId=...
     * <p>
     * Content-Type is set based on file extension (.parquet, .json, .csv).
     *
     * @param ctx Javalin request context
     */
    @OpenApi(
        path = "files/{path}",
        methods = {HttpMethod.GET},
        summary = "Download analytics file",
        description = "Streams an analytics artifact file (Parquet, JSON, or CSV) directly to the client. "
            + "The path parameter should be the relative path as returned by the /list endpoint.",
        tags = {"analyzer / analytics"},
        pathParams = {
            @OpenApiParam(
                name = "path", 
                description = "File path relative to analytics root (URL-encoded)", 
                required = true,
                example = "population/lod0/000/000/batch_00000000000000000000_00000000000000000999.parquet"
            )
        },
        queryParams = {
            @OpenApiParam(
                name = "runId", 
                description = "Simulation run ID", 
                required = true,
                example = "20251201-143025-550e8400-e29b-41d4-a716-446655440000"
            )
        },
        responses = {
            @OpenApiResponse(
                status = "200", 
                description = "File content (binary for Parquet, text for JSON/CSV)",
                content = {
                    @OpenApiContent(mimeType = "application/octet-stream"),
                    @OpenApiContent(mimeType = "application/json"),
                    @OpenApiContent(mimeType = "text/csv")
                }
            ),
            @OpenApiResponse(
                status = "400", 
                description = "Bad request (missing runId)", 
                content = @OpenApiContent(from = ErrorResponseDto.class)
            ),
            @OpenApiResponse(
                status = "404", 
                description = "File not found", 
                content = @OpenApiContent(from = ErrorResponseDto.class)
            )
        }
    )
    private void getFile(Context ctx) {
        String runId = ctx.queryParam("runId");
        String path = ctx.pathParam("path");

        if (runId == null || runId.isBlank()) {
            ctx.status(400).result("Missing runId parameter");
            return;
        }

        try {
            // Simple streaming
            InputStream in = storage.openAnalyticsInputStream(runId, path);
            ctx.result(in);
            
            // Set content type based on extension
            if (path.endsWith(".parquet")) {
                ctx.contentType("application/octet-stream");
            } else if (path.endsWith(".json")) {
                ctx.contentType("application/json");
            } else if (path.endsWith(".csv")) {
                ctx.contentType("text/csv");
            }
            
        } catch (Exception e) {
            log.warn("Failed to serve analytics file: {}/{}", runId, path);
            ctx.status(404).result("File not found");
        }
    }
}
